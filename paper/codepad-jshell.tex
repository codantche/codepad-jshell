\documentclass{article}
\usepackage{graphicx} 
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{plantuml}
\usepackage{url}

\usepackage{listings}
\usepackage{xcolor}

\lstdefinestyle{jshell}{
  language=Java,
  basicstyle=\ttfamily\small,
  backgroundcolor=\color{gray!5},
  frame=single,
  framerule=0.5pt,
  rulecolor=\color{gray!30},
  numbers=left,
  numberstyle=\tiny\color{gray},
  xleftmargin=1em,
  showstringspaces=false,
  tabsize=2,
  columns=flexible,
  moredelim=**[is][\color{blue}]{@}{@}, % for blue prompt like @jshell>
}

\lstset{style=jshell}

\title{Comparing Code Pad and JShell Features: A Pragmatic Pedagogical Perspective}
\author{Marco Mangan\thanks{\texttt{marco.mangan@gmail.com}}}
\date{October 2025}

\begin{document}

\maketitle

\begin{abstract}
Learning introductory programming remains a challenge, particularly when students are required to use professional tools. BlueJ, designed under the objects-first approach, provides a simplified environment and an interactive feature known as the Code Pad, which supports exploratory learning. Since the introduction of JShell in JDK 9, Java developers have gained a professional read–eval–print–loop (REPL) tool that overlaps with some of BlueJ’s interactive capabilities. This paper investigates whether JShell can offer a learning experience comparable to BlueJ’s Code Pad in the context of introductory computer science education. Through feature-oriented modeling, benchmark examples, and a review of related literature, we identify key similarities and differences between the two tools. The results suggest that while JShell enables more powerful and flexible interactions, BlueJ retains pedagogical advantages due to its visual modeling support and simplified interface. The study contributes to understanding how professional and educational environments can converge to support diverse student needs in programming education.
\end{abstract}

\section{Introduction}

This work presents a pragmatic, pedagogical comparison between BlueJ’s \textit{Code Pad} and Java’s \textit{JShell}. Rather than focusing on instructional theory, the study examines how students engage with the features that are effectively available in each environment while performing introductory programming tasks.

Learning to program computers is hard. By the late 1990s, the growing need to teach object-oriented programming sparked a broad discussion on instructional approaches. Historically, programmers developed their skills by progressing from computer architecture to assembly and then to early programming languages. Within this evolution, the understanding of objects typically came later.

With the growing prevalence of object-oriented languages such as C++ and Java, an \textit{objects-first} approach to teaching programming was advocated at that time. Before this shift, languages like BASIC, Smalltalk, and LISP were often learned directly—without prior exposure to other languages or to hardware concepts. Programming in these contexts occurred at a higher level of abstraction, and the \textit{objects-first} approach emerged as a natural extension of this perspective.

\textit{BlueJ} is a programming environment based on the \textit{objects-first} learning approach, first released in 1999 \cite{barnes2008objects, bluej_paper}. Among its many features, the \textit{Code Pad} was an innovation that allowed Java programmers to experiment with and explore commands without the need to write a complete application.

\textit{JShell} is a read–eval–print loop (REPL) introduced in JDK~9, around 2017 \cite{jshell_docs}. Some of its features are clearly similar to those found in BlueJ’s \textit{Code Pad} module and in earlier educational programming environments.

This resemblance raises the question of whether the interactive features once unique to BlueJ’s \textit{Code Pad} are still necessary in introductory programming, now that \textit{JShell} provides similar capabilities within the standard JDK.

Using \textit{JShell} may be a matter of personal preference, but to answer this question objectively we need to compare the features of \textit{Code Pad} and \textit{JShell}. This study adopts a pragmatic pedagogical perspective to identify and analyze the interactive features available in both environments.

The paper draws on feature-oriented modeling, benchmark examples, and literature review to identify key similarities and differences. The results are intended to inform educators and tool designers about how professional and educational environments can converge to better support introductory programming.

Ultimately, we need to better define what “education” means in programming, as professional developers never cease to learn. 

\section{Motivation}

Regardless of pedagogical foundations or teaching philosophy, students respond primarily to the tools actually at hand. Their exploratory behavior is therefore shaped more by the affordances of the environment—what the interface allows them to do—than by abstract learning principles. In this sense, tools such as BlueJ’s \textit{Code Pad} and Java’s \textit{JShell} not only mediate how students write code but also how they conceptualize programming itself.

This study is motivated by classroom observations in an undergraduate Computer Science course following the adoption of Java, BlueJ, and the \textit{objects-first} approach. Over several semesters, students have displayed distinct patterns of exploration and inquiry depending on the environment available to them.

Since the adoption of that approach, more than two decades have passed. During this period, three main factors have been observed: (a) a significant increase in computer literacy, (b) broader access to new devices and software, and (c) a shift in the very notion of what a computer program is.

\textit{BlueJ} is a desktop application whose look and feel contrast with that of contemporary software. In particular, its multiple-document interface has become one of the most distracting factors during classes.

Students often prefer other programming environments, most notably Microsoft Visual Studio Code. In some cases, there is even peer pressure from senior students to move directly to a more professional editor.

%Other editors include simple text editors, like Geany. No matter the editor, we can be sure that the Java Development Kit, which includes the Java Shell, is available.

Visual Studio Code can be run locally or in the cloud through a web browser. This flexibility allows students to use tablet devices while providing a more familiar and professional-looking interface. Some students bring their own laptops or tablets, but most have access to more than one computer. The cloud-based version of VS Code eliminates the need for separate Java and BlueJ installations and keeps all projects organized within the same cloud folder.

In this context, there is a clear need to provide a BlueJ-like experience for students who choose not to use the BlueJ environment.

\section{Research Question}

The central research question of this study is broad: can a BlueJ-like learning experience be achieved using professional tools such as Java’s \textit{JShell}?

\textit{BlueJ} includes many pedagogically grounded features. Therefore, it is necessary to compare the learning experience associated with each feature. This study focuses on the interactive and exploratory learning experience offered by BlueJ’s \textit{Code Pad}.

Therefore, the main research question of this study is:

\begin{quote}
\textit{Can the use of Java’s JShell provide students with a learning experience comparable to the one offered by BlueJ’s Code Pad?}
\end{quote}

Even with this focus, it is necessary to identify sub-features that enable a direct comparison between the two tools. By doing so, the study provides a list of pragmatic features that help clarify the learning experience offered by both environments.

% JShell was not available at the time BlueJ was proposed. Read–eval–print–loop shells had been available since the adoption of interpreted languages, including the Unix bash shell, BASIC, and popular languages such as Python and ECMAScript.

To answer this question, the study combines feature-oriented modeling, benchmark examples, and a review of related literature. This methodological combination allows a pragmatic and pedagogically informed comparison between BlueJ’s \textit{Code Pad} and Java’s \textit{JShell}, focusing on the interactive features that shape students’ learning experiences.

\section{Methodology}

The study combines literature review, benchmarking, and feature-oriented modeling to support a pragmatic comparison between \textit{BlueJ}’s \textit{Code Pad} and Java’s \textit{JShell}. The analysis follows a mixed qualitative and descriptive approach, emphasizing features that affect exploratory and interactive learning in introductory programming.

\subsection{Literature Review}

The literature review includes both educational and technical sources. Pedagogical aspects were examined through books and papers related to \textit{BlueJ} and the \textit{objects-first} approach \cite{barnes2008objects, bluej_paper}. Technical aspects were reviewed using the official \textit{JShell} documentation and complementary material describing its architecture, commands, and pedagogical potential \cite{jshell_docs}. Additional references were collected from textbooks and course materials frequently used in introductory programming, in order to extract representative code examples for benchmarking.

\subsection{Benchmarking and Feature Identification}

A set of examples was selected from the reviewed educational materials and executed in both environments. These examples include variable declarations, expression evaluation, object instantiation, and method invocation. Observations from these executions were used to construct a preliminary list of features shared or unique to each tool.

\subsection{Feature-Oriented Modeling}

The identified features were organized into a preliminary \textit{Feature-Oriented Domain Model} (FODM), representing the functional scope of each environment. This model served as a conceptual framework to compare \textit{BlueJ}’s \textit{Code Pad} and Java’s \textit{JShell} in terms of usability, interaction style, and pedagogical affordances.

\subsection{Comparative Analysis}

Both environments were compared from a pragmatic perspective, focusing on user experience rather than implementation. The analysis highlights objective aspects of interaction—such as immediacy of feedback, visualization, and command flexibility—while maintaining awareness of each tool’s pedagogical intent.

\subsection{Reproducibility and Tools}

All evidence and supplementary materials used in this study are available in the public repository \cite{mangan2025codepadjshell}. The research workflow employed \textit{Overleaf} for collaborative editing, and \textit{GitHub} (with Issues and Codespaces) for version control and reproducibility. ChatGPT~5 was used for text review, formatting consistency, and minor language editing.

%\section{Student Expectations}

%Get a job fast

%Use professional tools

%Write professional programs: mobile and Web clients, Web applications, games.

\section{Usage Scenarios}

This section presents a set of simple scenarios inspired by the exercises in Barnes and Kölling’s *Objects First with Java* \cite{barnes2008objects}. These examples were selected to illustrate how introductory programming tasks performed in BlueJ’s \textit{Code Pad} can be reproduced in Java’s \textit{JShell}.

\subsection{Evaluating Expressions}

Following the examples from the BlueJ book, the first scenario involves the evaluation of arithmetic expressions and method calls.

In BlueJ, the \textit{Code Pad} displays both the value and the data type of each evaluated expression. In addition, the internal structure of created objects can be visually inspected through the object bench and the inspector.

In contrast, JShell displays only the resulting value of each expression. The corresponding data types can be queried using the command \texttt{/vars}, which lists variables and their types. However, more advanced introspection commands would normally fall outside the scope of a first programming course. Nevertheless, the JShell command-line interface allows users to refer to previous results using automatically assigned identifiers (such as \texttt{\$1}, \texttt{\$2}), which can represent values, objects, or primitive types.

\begin{lstlisting}
jshell> 4 + 5
$1 ==> 9
\end{lstlisting}

Method call example:

\begin{lstlisting}
jshell> "Wombat".substring(3, 5)
$2 ==> "ba"
\end{lstlisting}

Other examples include:
\begin{itemize}
  \item Arithmetic operators such as \texttt{\%} (modulus), integer division, and floating-point division;
  \item Character and string concatenation;
  \item Autoboxing and unboxing of primitive and wrapper types;
  \item Pre- and post-increment or decrement operators;
  \item Operator precedence and associativity;
  \item Left-hand and right-hand expressions in assignments.
\end{itemize}


\subsection{Declaring Variables}

A common early activity in both environments is the declaration of variables. In BlueJ’s \textit{Code Pad}, students can declare and initialize variables using either explicit data types or the \texttt{var} keyword (from Java 10 onwards). In the 4\textsuperscript{th} edition of Barnes and Kölling’s book, examples typically use explicit types for primitive values and object references.

In BlueJ, the declaration of a variable such as \texttt{int x = 4;} results in the creation of a variable that can later be inspected through the object bench or by entering the variable name in the Code Pad. Reference types, such as \texttt{Circle} or \texttt{String}, appear as interactive icons in the object bench, allowing visual manipulation and inspection.

JShell provides equivalent functionality for declaring variables of primitive or reference types. Each declaration receives an automatic identifier and can be reviewed using the command \texttt{/vars}, which lists all current variables and their types.

\begin{lstlisting}
jshell> int x = 4;
x ==> 4

jshell> String name = "BlueJ";
name ==> "BlueJ"
\end{lstlisting}

JShell also supports the use of \texttt{var} for local type inference:

\begin{lstlisting}
jshell> var y = 3.14;
y ==> 3.14
\end{lstlisting}

Arrays and other compound data structures can also be declared interactively, providing immediate feedback similar to that obtained in BlueJ’s \textit{Code Pad}.

\begin{lstlisting}
jshell> int[] values = {1, 2, 3};
values ==> int[3] { 1, 2, 3 }
\end{lstlisting}

While JShell allows the declaration of records and other modern constructs, such features are beyond the scope of the early chapters of introductory programming courses. Nonetheless, their presence highlights JShell’s alignment with the current Java specification, offering continuity between educational and professional contexts.


\subsection{Inspecting Values and Objects}

Inspection is a central aspect of exploratory programming. In BlueJ, objects created through the \textit{Code Pad} appear as small red icons that can be dragged to the object bench. This two-way integration allows students to inspect an object’s internal state, invoke its methods through graphical menus, and visualize its attributes in a structured format. Such features reinforce the concept of objects as tangible entities, directly manipulable within the environment.

In contrast, JShell represents evaluated expressions and instantiated objects textually. Each result is automatically assigned an identifier such as \texttt{\$1}, \texttt{\$2}, and so on. These identifiers can be used in subsequent expressions to access or manipulate the corresponding values:

\begin{lstlisting}
jshell> new String("BlueJ")
$1 ==> "BlueJ"

jshell> $1.length()
$2 ==> 5
\end{lstlisting}

This mechanism provides continuity between expressions but offers no visual feedback. Objects are displayed in their string representation, and their internal structure remains opaque unless explicitly accessed through methods or reflection. While public interfaces can be explored programmatically, deeper introspection (such as listing fields or methods) requires commands and APIs that are generally beyond the scope of introductory programming courses.

Overall, BlueJ promotes visual and intuitive inspection through its graphical interface, whereas JShell relies on textual identifiers and explicit method calls. Both approaches support object manipulation, but they differ fundamentally in how learners perceive and explore program state.




\subsection{Import packages}
Java library, third party, user defined
Importing packages

\subsection{Load and reload code}
Changes on user defined code
After each compile

Are objects and values removed from memory at each reload?
 

\subsection{Conditionals, iteration, recursion}
if else
while, do while, for, for with array and collections

\subsection{Errors, Exceptions}
division by zero
null pointer

arrayindexoutofbounds

formatter

reading and writing files


\subsection{Input and output}
printf
format
regex

\subsection{Lambda and Streams}
lambdas
forEach(), mapTo(), count()

\subsection{GUI, file system, network}

\subsection{Saving scripts}

\subsection{Variability}
BlueJ Two-way integration with visual object model

BlueJ compiler, classpath, reload

Java Shell Id


\section{Pragmatic Feature Comparison}
Commonality and variability are

The comparison presented here focuses on what learners can directly experience in practice, rather than on the theoretical intent of each design.

\begin{quote}
As a novice programmer
I want to explore command interactively
so I can try new commands as soon I learn about them
\end{quote}


\section{Related Work}

At least on study points out the inadequacy of the Java Shell in the classroom
\cite{politz_minnes2018jshell}.


BeanShell early attempt

Python and Python Notebooks

BASIC and LISP.

\section{Discussion}

JShell is a professional tool

BlueJ integration of many features.

BlueJ features not provided by Java Shell include class and object visual models and their integration with Code Pad.

In order to compare the potential experience, we compare features of the applications.

The need for a in-classroom is reduced, because the feature model provides a objective reference point. Variation of performance among students is a complex task, because of confounding factors as motivation, previous experience, and problem solving skills.

A textual analysis of Objects First with Java revealed that most references to the Code Pad occur in exercises rather than in the main narrative. This suggests that the Code Pad’s pedagogical purpose was to foster exploratory learning through direct manipulation, rather than to illustrate concepts in a teacher-centered manner. In this sense, the Code Pad functions as an invitation to experiment, positioning students as active participants in their own discovery process.

JShell, as distributed within the standard JDK, lacks this framing. It provides equivalent functionality but without the explicit pedagogical scaffolding present in BlueJ’s textbook ecosystem.

Bean Shell exploratory programming
protoboard

types of software 
Type E

O termo feature é utilizado em diferentes tradições da Engenharia de Software. No contexto deste artigo, ele designa um recurso funcional das ferramentas Code Pad e JShell, em sentido semelhante ao uso em documentação técnica e em Sommerville (2015).
Reconhece-se, contudo, que o termo também possui acepções formais em Feature-Oriented Software Development (Kang et al., 1990; Batory et al., 2004) e em Behavior-Driven Development (North, 2006), onde descreve unidades de comportamento observável (feature files).

\section{Conclusion}

The Java Shell provides interactive and exploratory features that can improve the experience to programmers on all levels of maturity.

The use of professional tools on the classroom is a reality that calls for a more diverse set of tools, to accomodate a more diverse set of students.

All/many/some example of the benchmark can be reproduced using the Java Shell.

Code Pad has unique features, as the integration with visual models, and a simplified set of messages. 

Balance the power of the Java Shell with the easier adoption of BlueJ.

The pragmatic pedagogical lens adopted here emphasizes observable use: students explore, test, and learn through the specific feedback and interaction patterns that Code Pad or JShell provide.

Future work will formalize this comparison through feature modeling, allowing these pragmatic observations to be represented systematically

As a next step, we plan to formalize the comparative model using tools such as FeatureIDE, and to investigate other BlueJ features—especially visual modeling and object inspection—as subjects for future papers.

\bibliographystyle{plain}
\bibliography{refs}

\end{document}
