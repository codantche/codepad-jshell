\documentclass{article}
\usepackage{graphicx} 
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{plantuml}
\usepackage{url}

\usepackage{tabularx}
\usepackage{booktabs}

\usepackage{listings}
\usepackage{xcolor}

\lstdefinestyle{jshell}{
  language=Java,
  basicstyle=\ttfamily\small,
  backgroundcolor=\color{gray!5},
  frame=single,
  framerule=0.5pt,
  rulecolor=\color{gray!30},
  numbers=left,
  numberstyle=\tiny\color{gray},
  xleftmargin=1em,
  showstringspaces=false,
  tabsize=2,
  columns=flexible,
  moredelim=**[is][\color{blue}]{@}{@}, % for blue prompt like @jshell>
}

\lstset{style=jshell}

\title{Comparing Code Pad and JShell Features: A Pragmatic Pedagogical Perspective}
\author{Marco Mangan\thanks{\texttt{marco.mangan@gmail.com}}}
\date{October 2025}

\begin{document}

\maketitle

\begin{abstract}
Learning introductory programming remains a challenge, particularly when students are required to use professional tools. BlueJ, designed under the objects-first approach, provides a simplified environment and an interactive feature known as the Code Pad, which supports exploratory learning. Since the introduction of JShell in JDK 9, Java developers have gained a professional read–eval–print–loop (REPL) tool that overlaps with some of BlueJ’s interactive capabilities. This paper investigates whether JShell can offer a learning experience comparable to BlueJ’s Code Pad in the context of introductory computer science education. Through feature-oriented modeling, benchmark examples, and a review of related literature, we identify key similarities and differences between the two tools. The results suggest that while JShell enables more powerful and flexible interactions, BlueJ retains pedagogical advantages due to its visual modeling support and simplified interface. The study contributes to understanding how professional and educational environments can converge to support diverse student needs in programming education.
\end{abstract}

\section{Introduction}

This work presents a pragmatic, pedagogical comparison between BlueJ’s \textit{Code Pad} and Java’s \textit{JShell}. Rather than focusing on instructional theory, the study examines how students engage with the features that are effectively available in each environment while performing introductory programming tasks.

Learning to program computers is hard. By the late 1990s, the growing need to teach object-oriented programming sparked a broad discussion on instructional approaches. Historically, programmers developed their skills by progressing from computer architecture to assembly and then to early programming languages. Within this evolution, the understanding of objects typically came later.

With the growing prevalence of object-oriented languages such as C++ and Java, an \textit{objects-first} approach to teaching programming was advocated at that time. Before this shift, languages like BASIC, Smalltalk, and LISP were often learned directly—without prior exposure to other languages or to hardware concepts. Programming in these contexts occurred at a higher level of abstraction, and the \textit{objects-first} approach emerged as a natural extension of this perspective.

\textit{BlueJ} is a programming environment based on the \textit{objects-first} learning approach, first released in 1999 \cite{barnes2008objects, bluej_paper}. Among its many features, the \textit{Code Pad} was an innovation that allowed Java programmers to experiment with and explore commands without the need to write a complete application.

\textit{JShell} is a read–eval–print loop (REPL) introduced in JDK~9, around 2017 \cite{jshell_docs}. Some of its features are clearly similar to those found in BlueJ’s \textit{Code Pad} module and in earlier educational programming environments.

This resemblance raises the question of whether the interactive features once unique to BlueJ’s \textit{Code Pad} are still necessary in introductory programming, now that \textit{JShell} provides similar capabilities within the standard JDK.

Using \textit{JShell} may be a matter of personal preference, but to answer this question objectively we need to compare the features of \textit{Code Pad} and \textit{JShell}. This study adopts a pragmatic pedagogical perspective to identify and analyze the interactive features available in both environments.

The paper draws on feature-oriented modeling, benchmark examples, and literature review to identify key similarities and differences. The results are intended to inform educators and tool designers about how professional and educational environments can converge to better support introductory programming.

Ultimately, we need to better define what “education” means in programming, as professional developers never cease to learn. 

\section{Motivation}

Regardless of pedagogical foundations or teaching philosophy, students respond primarily to the tools actually at hand. Their exploratory behavior is therefore shaped more by the affordances of the environment—what the interface allows them to do—than by abstract learning principles. In this sense, tools such as BlueJ’s \textit{Code Pad} and Java’s \textit{JShell} not only mediate how students write code but also how they conceptualize programming itself.

This study is motivated by classroom observations in an undergraduate Computer Science course following the adoption of Java, BlueJ, and the \textit{objects-first} approach. Over several semesters, students have displayed distinct patterns of exploration and inquiry depending on the environment available to them.

Since the adoption of that approach, more than two decades have passed. During this period, three main factors have been observed: (a) a significant increase in computer literacy, (b) broader access to new devices and software, and (c) a shift in the very notion of what a computer program is.

\textit{BlueJ} is a desktop application whose look and feel contrast with that of contemporary software. In particular, its multiple-document interface has become one of the most distracting factors during classes.

Students often prefer other programming environments, most notably Microsoft Visual Studio Code. In some cases, there is even peer pressure from senior students to move directly to a more professional editor.

%Other editors include simple text editors, like Geany. No matter the editor, we can be sure that the Java Development Kit, which includes the Java Shell, is available.

Visual Studio Code can be run locally or in the cloud through a web browser. This flexibility allows students to use tablet devices while providing a more familiar and professional-looking interface. Some students bring their own laptops or tablets, but most have access to more than one computer. The cloud-based version of VS Code eliminates the need for separate Java and BlueJ installations and keeps all projects organized within the same cloud folder.

In this context, there is a clear need to provide a BlueJ-like experience for students who choose not to use the BlueJ environment.

\section{Research Question}

The central research question of this study is broad: can a BlueJ-like learning experience be achieved using professional tools such as Java’s \textit{JShell}?

\textit{BlueJ} includes many pedagogically grounded features. Therefore, it is necessary to compare the learning experience associated with each feature. This study focuses on the interactive and exploratory learning experience offered by BlueJ’s \textit{Code Pad}.

Therefore, the main research question of this study is:

\begin{quote}
\textit{Can the use of Java’s JShell provide students with a learning experience comparable to the one offered by BlueJ’s Code Pad?}
\end{quote}

Even with this focus, it is necessary to identify sub-features that enable a direct comparison between the two tools. By doing so, the study provides a list of pragmatic features that help clarify the learning experience offered by both environments.

% JShell was not available at the time BlueJ was proposed. Read–eval–print–loop shells had been available since the adoption of interpreted languages, including the Unix bash shell, BASIC, and popular languages such as Python and ECMAScript.

To answer this question, the study combines feature-oriented modeling, benchmark examples, and a review of related literature. This methodological combination allows a pragmatic and pedagogically informed comparison between BlueJ’s \textit{Code Pad} and Java’s \textit{JShell}, focusing on the interactive features that shape students’ learning experiences.

\section{Methodology}

The study combines literature review, benchmarking, and feature-oriented modeling to support a pragmatic comparison between \textit{BlueJ}’s \textit{Code Pad} and Java’s \textit{JShell}. The analysis follows a mixed qualitative and descriptive approach, emphasizing features that affect exploratory and interactive learning in introductory programming.

\subsection{Literature Review}

The literature review includes both educational and technical sources. Pedagogical aspects were examined through books and papers related to \textit{BlueJ} and the \textit{objects-first} approach \cite{barnes2008objects, bluej_paper}. Technical aspects were reviewed using the official \textit{JShell} documentation and complementary material describing its architecture, commands, and pedagogical potential \cite{jshell_docs}. Additional references were collected from textbooks and course materials frequently used in introductory programming, in order to extract representative code examples for benchmarking.

\subsection{Benchmarking and Feature Identification}

A set of examples was selected from the reviewed educational materials and executed in both environments. These examples include variable declarations, expression evaluation, object instantiation, and method invocation. Observations from these executions were used to construct a preliminary list of features shared or unique to each tool.

\subsection{Feature-Oriented Modeling}

The identified features were organized into a preliminary \textit{Feature-Oriented Domain Model} (FODM), representing the functional scope of each environment. This model served as a conceptual framework to compare \textit{BlueJ}’s \textit{Code Pad} and Java’s \textit{JShell} in terms of usability, interaction style, and pedagogical affordances.

\subsection{Comparative Analysis}

Both environments were compared from a pragmatic perspective, focusing on user experience rather than implementation. The analysis highlights objective aspects of interaction—such as immediacy of feedback, visualization, and command flexibility—while maintaining awareness of each tool’s pedagogical intent.

\subsection{Reproducibility and Tools}

All evidence and supplementary materials used in this study are available in the public repository \cite{mangan2025codepadjshell}. The research workflow employed \textit{Overleaf} for collaborative editing, and \textit{GitHub} (with Issues and Codespaces) for version control and reproducibility. ChatGPT~5 was used for text review, formatting consistency, and minor language editing.

%\section{Student Expectations}

%Get a job fast

%Use professional tools

%Write professional programs: mobile and Web clients, Web applications, games.

\section{Usage Scenarios}

This section presents a set of simple scenarios inspired by the exercises in Barnes and Kölling’s *Objects First with Java* \cite{barnes2008objects}. These examples were selected to illustrate how introductory programming tasks performed in BlueJ’s \textit{Code Pad} can be reproduced in Java’s \textit{JShell}.

\subsection{Evaluating Expressions}

Following the examples from the BlueJ book, the first scenario involves the evaluation of arithmetic expressions and method calls.

In BlueJ, the \textit{Code Pad} displays both the value and the data type of each evaluated expression. In addition, the internal structure of created objects can be visually inspected through the object bench and the inspector.

In contrast, JShell displays only the resulting value of each expression. The corresponding data types can be queried using the command \texttt{/vars}, which lists variables and their types. However, more advanced introspection commands would normally fall outside the scope of a first programming course. Nevertheless, the JShell command-line interface allows users to refer to previous results using automatically assigned identifiers (such as \texttt{\$1}, \texttt{\$2}), which can represent values, objects, or primitive types.

\begin{lstlisting}
jshell> 4 + 5
$1 ==> 9
\end{lstlisting}

Method call example:

\begin{lstlisting}
jshell> "Wombat".substring(3, 5)
$2 ==> "ba"
\end{lstlisting}

Other examples include:
\begin{itemize}
  \item Arithmetic operators such as \texttt{\%} (modulus), integer division, and floating-point division;
  \item Character and string concatenation;
  \item Autoboxing and unboxing of primitive and wrapper types;
  \item Pre- and post-increment or decrement operators;
  \item Operator precedence and associativity;
  \item Left-hand and right-hand expressions in assignments.
\end{itemize}


\subsection{Declaring Variables}

A common early activity in both environments is the declaration of variables. In BlueJ’s \textit{Code Pad}, students can declare and initialize variables using either explicit data types or the \texttt{var} keyword (from Java 10 onwards). In the 4\textsuperscript{th} edition of Barnes and Kölling’s book, examples typically use explicit types for primitive values and object references.

In BlueJ, the declaration of a variable such as \texttt{int x = 4;} results in the creation of a variable that can later be inspected through the object bench or by entering the variable name in the Code Pad. Reference types, such as \texttt{Circle} or \texttt{String}, appear as interactive icons in the object bench, allowing visual manipulation and inspection.

JShell provides equivalent functionality for declaring variables of primitive or reference types. Each declaration receives an automatic identifier and can be reviewed using the command \texttt{/vars}, which lists all current variables and their types.

\begin{lstlisting}
jshell> int x = 4;
x ==> 4

jshell> String name = "BlueJ";
name ==> "BlueJ"
\end{lstlisting}

JShell also supports the use of \texttt{var} for local type inference:

\begin{lstlisting}
jshell> var y = 3.14;
y ==> 3.14
\end{lstlisting}

Arrays and other compound data structures can also be declared interactively, providing immediate feedback similar to that obtained in BlueJ’s \textit{Code Pad}.

\begin{lstlisting}
jshell> int[] values = {1, 2, 3};
values ==> int[3] { 1, 2, 3 }
\end{lstlisting}

While JShell allows the declaration of records and other modern constructs, such features are beyond the scope of the early chapters of introductory programming courses. Nonetheless, their presence highlights JShell’s alignment with the current Java specification, offering continuity between educational and professional contexts.


\subsection{Inspecting Values and Objects}

Inspection is a central aspect of exploratory programming. In BlueJ, objects created through the \textit{Code Pad} appear as small red icons that can be dragged to the object bench. This two-way integration allows students to inspect an object’s internal state, invoke its methods through graphical menus, and visualize its attributes in a structured format. Such features reinforce the concept of objects as tangible entities, directly manipulable within the environment.

In contrast, JShell represents evaluated expressions and instantiated objects textually. Each result is automatically assigned an identifier such as \texttt{\$1}, \texttt{\$2}, and so on. These identifiers can be used in subsequent expressions to access or manipulate the corresponding values:

\begin{lstlisting}
jshell> new String("BlueJ")
$1 ==> "BlueJ"

jshell> $1.length()
$2 ==> 5
\end{lstlisting}

This mechanism provides continuity between expressions but offers no visual feedback. Objects are displayed in their string representation, and their internal structure remains opaque unless explicitly accessed through methods or reflection. While public interfaces can be explored programmatically, deeper introspection (such as listing fields or methods) requires commands and APIs that are generally beyond the scope of introductory programming courses.

Overall, BlueJ promotes visual and intuitive inspection through its graphical interface, whereas JShell relies on textual identifiers and explicit method calls. Both approaches support object manipulation, but they differ fundamentally in how learners perceive and explore program state.


\subsection{Importing Packages}

A fundamental aspect of programming in Java is the ability to reuse existing classes through package imports. Both BlueJ and JShell support importing Java library classes, third-party packages, and user-defined code, but they do so in distinct ways that reflect their pedagogical focus.

In BlueJ, imports are typically implicit: students rely on classes provided by the standard Java API or by project files already available in the BlueJ workspace. When external libraries are required, BlueJ offers a graphical option through the menu \textit{Project → Add Library...}, which adds JAR files to the project’s classpath without the need for command-line configuration. This simplifies experimentation while maintaining a controlled environment.

JShell, on the other hand, provides several mechanisms for extending its environment. Standard Java packages can be imported explicitly using the \texttt{import} statement, just as in regular Java programs:

\begin{lstlisting}
jshell> import java.util.*;
jshell> var list = new ArrayList<String>();
list ==> []
\end{lstlisting}

For user-defined or third-party code, JShell accepts additional classpaths when launched or during a session. The option \texttt{-cp} (or \texttt{--class-path}) can include directories or JAR files:

\begin{lstlisting}
jshell --class-path out:lib/some.jar
\end{lstlisting}

Inside an active session, the commands \texttt{/open} and \texttt{/load} allow on-demand inclusion of external source files or previously saved JShell scripts:

\begin{lstlisting}
jshell> /open MyClass.java
jshell> /load mysession.jsh
\end{lstlisting}

While BlueJ’s graphical interface abstracts classpath management for beginners, JShell exposes it explicitly, providing a more professional view of how Java resolves external dependencies. This difference reflects each tool’s intended audience: BlueJ emphasizes accessibility and guided learning, whereas JShell fosters autonomy and closer alignment with the standard Java toolchain.


\subsection{Loading and Reloading Code}

When user-defined code is edited and recompiled, each environment manages the update process differently, reflecting its internal architecture and pedagogical intent.

In BlueJ, any modification to a class requires explicit recompilation through the \textit{Compile} button. Once recompilation occurs, all existing objects of the modified class are automatically invalidated and removed from the object bench. This ensures consistency between the compiled class definition and its instantiated objects, but also interrupts the learner’s exploratory flow. The need to recreate objects after each change reinforces the notion of compilation as a discrete phase in the development process.

In contrast, JShell allows the redefinition of classes and methods directly within the same session. When a class is edited externally and reloaded using the command \texttt{/reload}, or when its definition is re-entered interactively, the previous version of the class is replaced. Variables and objects that reference the old class definition become invalid or inaccessible, but other unrelated session variables persist in memory.

\begin{lstlisting}
jshell> /open MyClass.java
jshell> var obj = new MyClass();
obj ==> MyClass@5a07e868
// After editing MyClass.java
jshell> /reload
|  Warning: class MyClass has been replaced.
\end{lstlisting}

JShell’s behavior offers greater flexibility for experimentation but introduces subtleties in state management that may confuse beginners. Objects created before a class redefinition cannot be reused, and there is no visual feedback to indicate their invalidation. Whereas BlueJ enforces consistency through visible recompilation and object removal, JShell delegates responsibility to the user, who must manually manage redefinitions and session resets.

Thus, BlueJ emphasizes the conceptual separation between compilation and execution, while JShell illustrates the dynamic nature of modern REPL-based workflows.

 
\subsection{Saving and Resuming Work}

Persistence of work differs significantly between BlueJ and JShell, reflecting their underlying design philosophies. BlueJ organizes programs into explicit projects composed of source files, compiled classes, and configuration data. Each project can be saved, closed, and reopened through graphical menu options such as \textit{Project → Save} or \textit{Project → Open Project...}. This model encourages structured development and makes it easier for beginners to associate their code with physical files stored on disk.

In contrast, JShell operates in an ephemeral session-based environment. By default, definitions created within a session—variables, imports, methods, and classes—exist only in memory. To preserve them, users must explicitly save the session using the \texttt{/save} command:

\begin{lstlisting}
jshell> /save session01.jsh
\end{lstlisting}

The saved file can later be reloaded with \texttt{/open} or \texttt{/load}, restoring the previous definitions:

\begin{lstlisting}
jshell> /open session01.jsh
\end{lstlisting}

This workflow aligns with interactive programming practices but differs from the file-oriented perspective taught in early programming courses. Beginners may find it less intuitive to manage code that is not visibly represented as files within a project structure. However, for advanced users, session files facilitate rapid prototyping and experimentation without the overhead of project configuration.

From a pedagogical standpoint, BlueJ’s project model reinforces the notion of code as a tangible artifact—something that can be organized, versioned, and revisited—whereas JShell prioritizes immediacy and iteration, supporting exploratory learning through temporary, editable sessions.



\subsection{Conditionals, Iteration, and Recursion}

Both BlueJ and JShell fully support the use of Java control structures such as \texttt{if}–\texttt{else}, \texttt{while}, \texttt{do–while}, and \texttt{for} loops. These constructs behave identically in both environments because they are evaluated by the same Java compiler and runtime.

In BlueJ’s \textit{Code Pad}, students can type short conditional statements or loop fragments to observe their immediate results. For example, using \texttt{if} statements to test Boolean expressions, or executing a \texttt{for} loop to print a sequence of values. When the code contains side effects, BlueJ provides visual feedback through the object bench, helping students observe changes in object state.

JShell allows the same structures to be executed interactively:

\begin{lstlisting}
jshell> for (int i = 0; i < 5; i++) System.out.print(i + " ");
0 1 2 3 4 
\end{lstlisting}

Because of its REPL nature, JShell encourages short, self-contained experiments with control flow. Recursion can also be tested interactively by defining methods inline, for example:

\begin{lstlisting}
jshell> int factorial(int n) { return n <= 1 ? 1 : n * factorial(n - 1); }
jshell> factorial(5)
$1 ==> 120
\end{lstlisting}

This flexibility helps learners test ideas incrementally, but without the visual cues present in BlueJ.

---

\subsection{Errors and Exceptions}

Error reporting is another area where the two environments differ in presentation. In BlueJ, syntax or compilation errors are visually indicated in the editor, with colored highlights and messages shown below the source pane. Runtime exceptions such as division by zero, null references, or array index violations are displayed in dialog boxes, guiding students toward the relevant line or expression.

JShell, by contrast, reports all errors textually within the command-line interface. Compilation errors are printed immediately after the offending statement, and runtime exceptions generate stack traces similar to those found in professional IDEs:

\begin{lstlisting}
jshell> 10 / 0
|  java.lang.ArithmeticException: / by zero
\end{lstlisting}

Other common exceptions behave similarly, such as \texttt{NullPointerException} or \texttt{ArrayIndexOutOfBoundsException}. Although this textual feedback is precise, it may be intimidating for beginners unfamiliar with stack traces. BlueJ’s graphical presentation, while simplified, provides a gentler introduction to debugging concepts.

Both tools support formatted output and file operations, but BlueJ requires explicit coding within classes, whereas JShell allows direct execution of I/O statements for quick testing, including use of \texttt{System.out.printf()} or file readers and writers. This distinction further illustrates BlueJ’s emphasis on structure versus JShell’s emphasis on immediacy.


\subsection{Input and Output}

In BlueJ, input and output are typically introduced through console printing and file manipulation inside class methods. Examples such as \texttt{System.out.println()} or formatted output using \texttt{printf()} are embedded within complete methods. 

JShell enables these same operations interactively, making it possible to test formatting, regular expressions, and string manipulation directly:

\begin{lstlisting}
jshell> System.out.printf("%d %04d %s%n", 1, 23, "BlueJ");
1 0023 BlueJ
\end{lstlisting}

Students can also experiment with the \texttt{String.format()} and regular expression APIs without creating auxiliary classes. This immediacy can accelerate learning of Java’s standard library, though it bypasses some of the structural discipline emphasized in project-based environments.

---

\subsection{Lambdas and Streams}

Although not typically part of a first programming course, both BlueJ and JShell can execute Java expressions that involve lambda functions and streams. BlueJ treats these constructs as standard Java syntax within classes or methods. JShell, however, makes it easier to test them interactively:

\begin{lstlisting}
jshell> var list = List.of(1, 2, 3, 4, 5);
jshell> list.stream().map(x -> x * 2).forEach(System.out::println);
2
4
6
8
10
\end{lstlisting}

Such examples demonstrate how JShell extends beyond the typical educational use case, bridging introductory learning with more advanced, professional practices. Instructors can use JShell to preview features like functional programming without requiring full project setup.

---

\subsection{Variability Across Environments}

Despite their shared Java foundation, BlueJ and JShell exhibit variability in how features are accessed and experienced. BlueJ offers two-way integration with its visual object model, combining source editing, compilation, and direct object manipulation. Its compiler, classpath configuration, and reloading mechanisms are encapsulated within the environment, shielding beginners from underlying complexity.

JShell, in contrast, exposes these mechanisms explicitly. It manages identifiers (\texttt{\$1}, \texttt{\$2}, etc.) for evaluated expressions and relies on textual commands for imports, reloading, and environment management. This transparency aligns with professional workflows but assumes a higher degree of autonomy from the learner.

From a pedagogical view, BlueJ’s variability lies in its abstraction—with less complex operations through a visual interface—whereas JShell’s variability arises from its openness, offering multiple ways to achieve the same goal through direct commands.


\section{Pragmatic Feature Comparison}

Commonality and variability between BlueJ and JShell can be analyzed in terms of their directly observable behavior. Rather than focusing on the theoretical intent of each environment’s design, this comparison emphasizes what learners can concretely experience in practice.

\begin{quote}
\textit{As a novice programmer,  
I want to explore commands interactively  
so that I can try new ideas as soon as I learn about them.}
\end{quote}

This pragmatic perspective shifts the focus from software architecture or pedagogical philosophy to user experience—how a student interacts with the tool, receives feedback, and develops understanding through action. Each feature or scenario represents a small learning opportunity, where interaction design either supports or hinders exploration.

Table~\ref{tab:features} summarizes the main features observed in both environments, organized according to the scenarios previously discussed. The table highlights both common elements (functional equivalence) and variable aspects (differences in presentation, feedback, or usability).

\begin{table}[h]
\centering
\caption{Pragmatic Feature Comparison between BlueJ and JShell}
\label{tab:features}

%\begin{tabular}{p{3cm} p{5cm} p{5cm}}
\begin{tabularx}{\linewidth}{>{\raggedright\arraybackslash}p{0.22\linewidth}
                                 >{\raggedright\arraybackslash}p{0.38\linewidth}
                                 >{\raggedright\arraybackslash}p{0.38\linewidth}}
\toprule
\textbf{Scenario / Feature} & \textbf{BlueJ Code Pad} & \textbf{JShell} \\
\midrule
Evaluate expressions & Shows value and type; visual feedback through object icons & Shows value only; textual output with automatic identifiers (\$1, \$2, ...) \\
Declare variables & Variables appear in the object bench for inspection & Variables listed via \texttt{/vars} command \\
Inspect objects & Graphical object inspector; interactive method calls & String representation only; introspection via method calls \\
Load and reload code & Requires explicit recompilation; objects cleared from bench & Allows class redefinition via \texttt{/reload}; existing variables persist \\
Import packages & \textit{Add Library...} menu; automatic classpath management & Manual import and classpath control using \texttt{--class-path}, \texttt{/open}, \texttt{/load} \\
Save and resume work & Project-based; stored on disk with compiled files & Session-based; must use \texttt{/save} and \texttt{/open} \\
Error and exception handling & Visual error highlighting; dialogs for runtime exceptions & Textual stack traces; command-line diagnostics \\
Lambdas and streams & Executed within full class context; limited in early courses & Fully supported interactively; aligns with modern Java features \\
\bottomrule
\end{tabularx}
\end{table}

The table serves as a preliminary step toward a Feature-Oriented Domain Model (FODM), identifying which interactions are shared and which are unique to each environment. Commonalities suggest stable pedagogical patterns, whereas variabilities point to opportunities for improvement or integration across tools.




\section{Related Work}

Several environments have been proposed to support introductory programming, balancing pedagogical simplicity with professional relevance. This study builds upon that tradition by examining the interactive features of BlueJ’s \textit{Code Pad} and Java’s \textit{JShell}.

At least one recent study explicitly points out the inadequacy of JShell in classroom contexts. Politz and Minnes \cite{politz_minnes2018jshell} argue that although JShell provides a standard REPL for Java, its design prioritizes professional usage over pedagogical usability. Their findings suggest that without scaffolding or visual feedback, students may struggle to understand object state and program structure.

Before JShell, earlier attempts at interactive Java environments included BeanShell, a lightweight interpreter that supported scripting and command-line evaluation of Java code. BeanShell demonstrated the feasibility of interactive Java execution long before it became part of the JDK, but it lacked full language compatibility and integration with educational workflows.

BlueJ itself belongs to a family of educational programming tools such as Greenfoot and DrJava. Greenfoot extended the BlueJ philosophy into a more visual, animation-based environment aimed at younger learners, while DrJava provided a lightweight IDE for teaching standard Java syntax with simplified project management. Each of these environments shared the goal of making Java more approachable to novices through interactive and incremental experimentation.

Outside the Java ecosystem, Python and its interactive notebooks (Jupyter, Google Colab) have become dominant tools for both education and research. These environments integrate code, execution, and explanation in a single interface, exemplifying the pedagogical power of immediate feedback. They also demonstrate how professional and educational uses can coexist within the same platform—an idea conceptually similar to JShell’s role within the JDK.

Visual programming environments form another relevant category. Game-development tools such as Unity incorporate node-based scripting systems that allow users to manipulate program logic visually. Similarly, modern workflow automation tools such as n8n and Node-RED employ visual metaphors for data flow and control structures. Although aimed at professional developers, they share with educational tools the goal of making computation visible and manipulable.

Historically, visual representations of algorithms—such as flowcharts and UML activity diagrams—served as early forms of structured programming visualization. These notations, along with educational languages such as BASIC and LISP, established the foundations of interactive and exploratory learning environments that remain influential today.

Taken together, these precedents contextualize the comparison between BlueJ and JShell within a broader continuum of interactive programming tools. From early educational languages to modern professional REPLs and visual systems, the ongoing challenge remains how to reconcile ease of learning with fidelity to real-world programming practice.

\section{Discussion}

JShell is primarily a professional tool. As part of the standard Java Development Kit, it was designed to facilitate rapid experimentation for experienced developers. Its interface and feedback mechanisms reflect this purpose, prioritizing flexibility and completeness over visual guidance. In contrast, BlueJ integrates multiple features specifically tailored for learning, including visual object models, simplified project management, and seamless interaction between source code, object diagrams, and the Code Pad.

Among these features, BlueJ’s graphical representation of classes and objects—combined with its two-way integration with the Code Pad—has no direct equivalent in JShell. This integration allows learners to move fluidly between textual commands and visual feedback, reinforcing the conceptual relationship between code and runtime behavior. JShell, while offering equivalent computational functionality, lacks this visual affordance and the pedagogical scaffolding that accompanies it in the BlueJ ecosystem.

To compare the potential learning experience between these tools, this study examined their interactive features as observable phenomena. Rather than measuring learning outcomes in the classroom, which would require complex control of confounding factors such as student motivation, prior experience, and problem-solving skills, the analysis focuses on a pragmatic feature comparison. The resulting model serves as an objective reference point, identifying which aspects of the user experience are shared and which differ fundamentally.

A textual analysis of \textit{Objects First with Java} revealed that most references to the Code Pad occur in exercises rather than in the main explanatory narrative. This pattern suggests that the Code Pad was conceived as a space for experimentation—an invitation for students to test hypotheses, explore expressions, and learn through active discovery. In this sense, it functions less as a demonstration tool and more as a pedagogical bridge between reading and doing.

JShell, as distributed within the JDK, provides similar capabilities but lacks the explicit instructional framing found in BlueJ’s textbook and interface. While it supports exploration, it does not explicitly invite it. The absence of guided discovery elements—such as object icons, contextual menus, or exercise references—may limit its immediate pedagogical impact, even though it offers greater technical breadth.

Earlier tools such as BeanShell anticipated this mode of exploratory programming. Like a protoboard used in electronics education, BeanShell allowed rapid assembly and testing of small components without the overhead of full program compilation. JShell inherits this spirit but applies it within a professional-grade toolchain, closing the gap between educational and industrial environments.

Different categories of software can be associated with different modes of use. Following the classification of “Type E” systems (exploratory systems), educational programming environments prioritize experimentation and conceptual reinforcement. Both BlueJ and JShell can support exploratory learning, but they do so through distinct affordances: BlueJ through visual structure and integration, JShell through immediacy and professional continuity.

Finally, it is worth clarifying the use of the term \textit{feature}. The word appears across several traditions in Software Engineering. In the context of this study, it designates a functional capability of the Code Pad and JShell—consistent with its usage in technical documentation and in Sommerville (2015). However, the term also has formal meanings in Feature-Oriented Software Development (Kang et al., 1990; Batory et al., 2004) and in Behavior-Driven Development (North, 2006), where it refers to observable units of system behavior (feature files). The pragmatic interpretation adopted here aligns more closely with the everyday sense of “capability,” focusing on the learner’s experience of what each environment enables or constrains.


\section{Conclusion}

The Java Shell provides interactive and exploratory features that can enhance the programming experience for learners and professionals alike. By integrating a modern read–eval–print loop into the Java ecosystem, JShell enables immediate experimentation and rapid feedback—qualities long associated with more dynamically typed languages. Its inclusion in the JDK reflects the recognition that exploration and iteration are central to learning and software development at all levels of maturity.

At the same time, the increasing use of professional tools in the classroom highlights the need for a more diverse ecosystem of environments, capable of accommodating a wide range of student profiles and learning preferences. While many of the examples drawn from the BlueJ textbook can be reproduced within JShell, certain pedagogical elements remain unique to BlueJ, particularly its integration of visual class and object models and its simplified, structured feedback. These features continue to offer important scaffolding for learners taking their first steps in programming.

The challenge, therefore, is not to replace one tool with another, but to balance the power and realism of professional environments like JShell with the accessibility and pedagogical focus of educational tools such as BlueJ. A pragmatic pedagogical perspective, as adopted in this study, directs attention to what students can actually do and observe: they explore, test, and learn through the specific forms of feedback and interaction each environment affords.

Future work will formalize this comparison through feature modeling, enabling these pragmatic observations to be represented systematically. As a next step, we plan to develop a feature-oriented domain model using tools such as FeatureIDE, extending the analysis to other aspects of BlueJ—including visual modeling and object inspection—as potential subjects for subsequent studies.
\bibliographystyle{plain}
\bibliography{refs}

\end{document}
